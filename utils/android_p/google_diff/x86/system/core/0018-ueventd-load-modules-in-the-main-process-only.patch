From d8d246cb66491f43d410a48d31909cbe0c11d2fb Mon Sep 17 00:00:00 2001
From: Chih-Wei Huang <cwhuang@linux.org.tw>
Date: Wed, 27 Dec 2017 12:10:38 +0800
Subject: [PATCH 18/23] ueventd: load modules in the main process only

Loading modules in multiple processes is dangerous. It may cause
the system to hang.

Only handle uevents with modalias in the main process so that
all modules are loaded sequentially.
---
 init/devices.cpp | 24 ++++++++++++++----------
 init/devices.h   |  2 +-
 init/ueventd.cpp |  3 ++-
 3 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/init/devices.cpp b/init/devices.cpp
index b3f0e41932..7efe287275 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -380,7 +380,6 @@ void DeviceHandler::HandleDevice(const std::string& action, const std::string& d
 
 void DeviceHandler::HandleDeviceEvent(const Uevent& uevent) {
     if (uevent.action == "add" || uevent.action == "change" || uevent.action == "online") {
-        LoadModule(uevent);
         FixupSysPermissions(uevent.path, uevent.subsystem);
     }
 
@@ -441,28 +440,33 @@ void DeviceHandler::HandleDeviceEvent(const Uevent& uevent) {
     HandleDevice(uevent.action, devpath, block, uevent.major, uevent.minor, links);
 }
 
-void DeviceHandler::HandleModuleEvent(const Uevent& uevent, std::vector<std::string>& mod_queue)
+void DeviceHandler::HandleModuleEvent(const Uevent& uevent, std::vector<std::string>* mod_queue)
 {
     if (!uevent.modalias.empty() && uevent.action == "add") {
         if (mod_aliases_.empty()) {
             ReadModulesDescFiles();
         }
-        for (auto& entry : deferred_mod_aliases_) {
-            if (!fnmatch(entry.first.c_str(), uevent.modalias.c_str(), 0)) {
-                mod_queue.emplace_back(entry.second);
+        bool deferred = false;
+        if (mod_queue) {
+            for (auto& entry : deferred_mod_aliases_) {
+                if (!fnmatch(entry.first.c_str(), uevent.modalias.c_str(), 0)) {
+                    mod_queue->emplace_back(entry.second);
+                    deferred = true;
+                }
             }
         }
+        if (!deferred) {
+            LoadModule(uevent);
+        }
     }
 }
 
 bool DeviceHandler::LoadModule(const Uevent& uevent) const
 {
     bool ret = false;
-    if (!uevent.modalias.empty()) {
-        for (auto& entry : mod_aliases_) {
-            if (!fnmatch(entry.first.c_str(), uevent.modalias.c_str(), 0)) {
-                ret |= LoadModule(entry.second);
-            }
+    for (auto& entry : mod_aliases_) {
+        if (!fnmatch(entry.first.c_str(), uevent.modalias.c_str(), 0)) {
+            ret |= LoadModule(entry.second);
         }
     }
     return ret;
diff --git a/init/devices.h b/init/devices.h
index d8ae4c4739..36d696265f 100644
--- a/init/devices.h
+++ b/init/devices.h
@@ -110,7 +110,7 @@ class DeviceHandler {
     ~DeviceHandler(){};
 
     void HandleDeviceEvent(const Uevent& uevent);
-    void HandleModuleEvent(const Uevent& uevent, std::vector<std::string>& mod_queue);
+    void HandleModuleEvent(const Uevent& uevent, std::vector<std::string>* mod_queue = nullptr);
     bool LoadModule(const Uevent& uevent) const;
     bool LoadModule(const std::string& mod) const;
     void ReadModulesDescFiles();
diff --git a/init/ueventd.cpp b/init/ueventd.cpp
index 88843d987e..b8e065e517 100644
--- a/init/ueventd.cpp
+++ b/init/ueventd.cpp
@@ -143,7 +143,7 @@ void ColdBoot::UeventHandlerMain(unsigned int process_num, unsigned int total_pr
 void ColdBoot::RegenerateUevents() {
     uevent_listener_.RegenerateUevents([this](const Uevent& uevent) {
         HandleFirmwareEvent(uevent);
-        device_handler_.HandleModuleEvent(uevent, mod_queue_);
+        device_handler_.HandleModuleEvent(uevent, &mod_queue_);
         uevent_queue_.emplace_back(std::move(uevent));
         return ListenerAction::kContinue;
     });
@@ -287,6 +287,7 @@ int ueventd_main(int argc, char** argv) {
 
     uevent_listener.Poll([&device_handler](const Uevent& uevent) {
         HandleFirmwareEvent(uevent);
+        device_handler.HandleModuleEvent(uevent);
         device_handler.HandleDeviceEvent(uevent);
         return ListenerAction::kContinue;
     });
-- 
2.17.1

