From 5005f4e0ded584332ce6516192e673dd492ddd6c Mon Sep 17 00:00:00 2001
From: Jon West <electrikjesus@gmail.com>
Date: Fri, 8 Mar 2019 13:07:17 -0500
Subject: [PATCH] Add libnativehelper includes for abipicker

Change-Id: I87478b967b7e7576c0c327fcd61efa231654c2a7
---
 .../nativehelper/AsynchronousCloseMonitor.h   |  65 +++++
 core/jni/include/nativehelper/JNIHelp.h       | 222 +++++++++++++++++
 core/jni/include/nativehelper/JniConstants.h  |  85 +++++++
 core/jni/include/nativehelper/JniInvocation.h |  73 ++++++
 core/jni/include/nativehelper/ScopedBytes.h   |  23 ++
 .../include/nativehelper/ScopedLocalFrame.h   |  22 ++
 .../jni/include/nativehelper/ScopedLocalRef.h |  23 ++
 .../nativehelper/ScopedPrimitiveArray.h       |  23 ++
 .../include/nativehelper/ScopedStringChars.h  |  23 ++
 .../jni/include/nativehelper/ScopedUtfChars.h |  23 ++
 core/jni/include/nativehelper/UniquePtr.h     | 228 ++++++++++++++++++
 core/jni/include/nativehelper/toStringArray.h |  71 ++++++
 12 files changed, 881 insertions(+)
 create mode 100644 core/jni/include/nativehelper/AsynchronousCloseMonitor.h
 create mode 100644 core/jni/include/nativehelper/JNIHelp.h
 create mode 100644 core/jni/include/nativehelper/JniConstants.h
 create mode 100644 core/jni/include/nativehelper/JniInvocation.h
 create mode 100644 core/jni/include/nativehelper/ScopedBytes.h
 create mode 100644 core/jni/include/nativehelper/ScopedLocalFrame.h
 create mode 100644 core/jni/include/nativehelper/ScopedLocalRef.h
 create mode 100644 core/jni/include/nativehelper/ScopedPrimitiveArray.h
 create mode 100644 core/jni/include/nativehelper/ScopedStringChars.h
 create mode 100644 core/jni/include/nativehelper/ScopedUtfChars.h
 create mode 100644 core/jni/include/nativehelper/UniquePtr.h
 create mode 100644 core/jni/include/nativehelper/toStringArray.h

diff --git a/core/jni/include/nativehelper/AsynchronousCloseMonitor.h b/core/jni/include/nativehelper/AsynchronousCloseMonitor.h
new file mode 100644
index 000000000000..2afc35cc26ac
--- /dev/null
+++ b/core/jni/include/nativehelper/AsynchronousCloseMonitor.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ASYNCHRONOUS_CLOSE_MONITOR_H_included
+#define ASYNCHRONOUS_CLOSE_MONITOR_H_included
+
+#include <pthread.h>
+
+/**
+ * AsynchronousCloseMonitor helps implement Java's asynchronous close semantics.
+ *
+ * AsynchronousCloseMonitor::init must be called before anything else.
+ *
+ * Every blocking I/O operation must be surrounded by an AsynchronousCloseMonitor
+ * instance. For example:
+ *
+ *   {
+ *     AsynchronousCloseMonitor monitor(fd);
+ *     byteCount = ::read(fd, buf, sizeof(buf));
+ *   }
+ *
+ * To interrupt all threads currently blocked on file descriptor 'fd', call signalBlockedThreads:
+ *
+ *   AsynchronousCloseMonitor::signalBlockedThreads(fd);
+ *
+ * To test to see if the interruption was due to the signalBlockedThreads call:
+ *
+ *   monitor.wasSignaled();
+ */
+class AsynchronousCloseMonitor {
+public:
+    explicit AsynchronousCloseMonitor(int fd);
+    ~AsynchronousCloseMonitor();
+    bool wasSignaled() const;
+
+    static void init();
+
+    static void signalBlockedThreads(int fd);
+
+private:
+    AsynchronousCloseMonitor* mPrev;
+    AsynchronousCloseMonitor* mNext;
+    pthread_t mThread;
+    int mFd;
+    bool mSignaled;
+
+    // Disallow copy and assignment.
+    AsynchronousCloseMonitor(const AsynchronousCloseMonitor&);
+    void operator=(const AsynchronousCloseMonitor&);
+};
+
+#endif  // ASYNCHRONOUS_CLOSE_MONITOR_H_included
diff --git a/core/jni/include/nativehelper/JNIHelp.h b/core/jni/include/nativehelper/JNIHelp.h
new file mode 100644
index 000000000000..6c7da342420c
--- /dev/null
+++ b/core/jni/include/nativehelper/JNIHelp.h
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * JNI helper functions.
+ *
+ * This file may be included by C or C++ code, which is trouble because jni.h
+ * uses different typedefs for JNIEnv in each language.
+ *
+ * TODO: remove C support.
+ */
+#ifndef NATIVEHELPER_JNIHELP_H_
+#define NATIVEHELPER_JNIHELP_H_
+
+#include "jni.h"
+#include <errno.h>
+#include <unistd.h>
+
+#ifndef NELEM
+# define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Register one or more native methods with a particular class.
+ * "className" looks like "java/lang/String". Aborts on failure.
+ * TODO: fix all callers and change the return type to void.
+ */
+int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods);
+
+/*
+ * Throw an exception with the specified class and an optional message.
+ *
+ * The "className" argument will be passed directly to FindClass, which
+ * takes strings with slashes (e.g. "java/lang/Object").
+ *
+ * If an exception is currently pending, we log a warning message and
+ * clear it.
+ *
+ * Returns 0 on success, nonzero if something failed (e.g. the exception
+ * class couldn't be found, so *an* exception will still be pending).
+ *
+ * Currently aborts the VM if it can't throw the exception.
+ */
+int jniThrowException(C_JNIEnv* env, const char* className, const char* msg);
+
+/*
+ * Throw a java.lang.NullPointerException, with an optional message.
+ */
+int jniThrowNullPointerException(C_JNIEnv* env, const char* msg);
+
+/*
+ * Throw a java.lang.RuntimeException, with an optional message.
+ */
+int jniThrowRuntimeException(C_JNIEnv* env, const char* msg);
+
+/*
+ * Throw a java.io.IOException, generating the message from errno.
+ */
+int jniThrowIOException(C_JNIEnv* env, int errnum);
+
+/*
+ * Return a pointer to a locale-dependent error string explaining errno
+ * value 'errnum'. The returned pointer may or may not be equal to 'buf'.
+ * This function is thread-safe (unlike strerror) and portable (unlike
+ * strerror_r).
+ */
+const char* jniStrError(int errnum, char* buf, size_t buflen);
+
+/*
+ * Returns a new java.io.FileDescriptor for the given int fd.
+ */
+jobject jniCreateFileDescriptor(C_JNIEnv* env, int fd);
+
+/*
+ * Returns the int fd from a java.io.FileDescriptor.
+ */
+int jniGetFDFromFileDescriptor(C_JNIEnv* env, jobject fileDescriptor);
+
+/*
+ * Sets the int fd in a java.io.FileDescriptor.
+ */
+void jniSetFileDescriptorOfFD(C_JNIEnv* env, jobject fileDescriptor, int value);
+
+/*
+ * Returns the reference from a java.lang.ref.Reference.
+ */
+jobject jniGetReferent(C_JNIEnv* env, jobject ref);
+
+/*
+ * Returns a Java String object created from UTF-16 data either from jchar or,
+ * if called from C++11, char16_t (a bitwise identical distinct type).
+ */
+jstring jniCreateString(C_JNIEnv* env, const jchar* unicodeChars, jsize len);
+
+/*
+ * Log a message and an exception.
+ * If exception is NULL, logs the current exception in the JNI environment.
+ */
+void jniLogException(C_JNIEnv* env, int priority, const char* tag, jthrowable exception);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/*
+ * For C++ code, we provide inlines that map to the C functions.  g++ always
+ * inlines these, even on non-optimized builds.
+ */
+#if defined(__cplusplus)
+inline int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) {
+    return jniRegisterNativeMethods(&env->functions, className, gMethods, numMethods);
+}
+
+inline int jniThrowException(JNIEnv* env, const char* className, const char* msg) {
+    return jniThrowException(&env->functions, className, msg);
+}
+
+extern "C" int jniThrowExceptionFmt(C_JNIEnv* env, const char* className, const char* fmt, va_list args);
+
+/*
+ * Equivalent to jniThrowException but with a printf-like format string and
+ * variable-length argument list. This is only available in C++.
+ */
+inline int jniThrowExceptionFmt(JNIEnv* env, const char* className, const char* fmt, ...) {
+    va_list args;
+    va_start(args, fmt);
+    return jniThrowExceptionFmt(&env->functions, className, fmt, args);
+    va_end(args);
+}
+
+inline int jniThrowNullPointerException(JNIEnv* env, const char* msg) {
+    return jniThrowNullPointerException(&env->functions, msg);
+}
+
+inline int jniThrowRuntimeException(JNIEnv* env, const char* msg) {
+    return jniThrowRuntimeException(&env->functions, msg);
+}
+
+inline int jniThrowIOException(JNIEnv* env, int errnum) {
+    return jniThrowIOException(&env->functions, errnum);
+}
+
+inline jobject jniCreateFileDescriptor(JNIEnv* env, int fd) {
+    return jniCreateFileDescriptor(&env->functions, fd);
+}
+
+inline int jniGetFDFromFileDescriptor(JNIEnv* env, jobject fileDescriptor) {
+    return jniGetFDFromFileDescriptor(&env->functions, fileDescriptor);
+}
+
+inline void jniSetFileDescriptorOfFD(JNIEnv* env, jobject fileDescriptor, int value) {
+    jniSetFileDescriptorOfFD(&env->functions, fileDescriptor, value);
+}
+
+inline jobject jniGetReferent(JNIEnv* env, jobject ref) {
+    return jniGetReferent(&env->functions, ref);
+}
+
+inline jstring jniCreateString(JNIEnv* env, const jchar* unicodeChars, jsize len) {
+    return jniCreateString(&env->functions, unicodeChars, len);
+}
+
+#if __cplusplus >= 201103L
+inline jstring jniCreateString(JNIEnv* env, const char16_t* unicodeChars, jsize len) {
+    return jniCreateString(&env->functions, reinterpret_cast<const jchar*>(unicodeChars), len);
+}
+#endif  // __cplusplus >= 201103L
+
+inline void jniLogException(JNIEnv* env, int priority, const char* tag, jthrowable exception = NULL) {
+    jniLogException(&env->functions, priority, tag, exception);
+}
+
+#if !defined(DISALLOW_COPY_AND_ASSIGN)
+// DISALLOW_COPY_AND_ASSIGN disallows the copy and operator= functions. It goes in the private:
+// declarations in a class.
+#if __cplusplus >= 201103L
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&) = delete;  \
+  void operator=(const TypeName&) = delete
+#else
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&);  \
+  void operator=(const TypeName&)
+#endif  // __has_feature(cxx_deleted_functions)
+#endif  // !defined(DISALLOW_COPY_AND_ASSIGN)
+
+#endif
+
+/*
+ * TEMP_FAILURE_RETRY is defined by some, but not all, versions of
+ * <unistd.h>. (Alas, it is not as standard as we'd hoped!) So, if it's
+ * not already defined, then define it here.
+ */
+#ifndef TEMP_FAILURE_RETRY
+/* Used to retry syscalls that can return EINTR. */
+#define TEMP_FAILURE_RETRY(exp) ({         \
+    typeof (exp) _rc;                      \
+    do {                                   \
+        _rc = (exp);                       \
+    } while (_rc == -1 && errno == EINTR); \
+    _rc; })
+#endif
+
+#endif  /* NATIVEHELPER_JNIHELP_H_ */
diff --git a/core/jni/include/nativehelper/JniConstants.h b/core/jni/include/nativehelper/JniConstants.h
new file mode 100644
index 000000000000..a3d917f73343
--- /dev/null
+++ b/core/jni/include/nativehelper/JniConstants.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JNI_CONSTANTS_H_included
+#define JNI_CONSTANTS_H_included
+
+#include "JNIHelp.h"
+
+/**
+ * A cache to avoid calling FindClass at runtime.
+ *
+ * Class lookup is relatively expensive, so we do these lookups at startup. This means that code
+ * that never uses, say, java.util.zip.Deflater still has to pay for the lookup, but it means that
+ * on device the cost is paid during boot and amortized. A central cache also removes the temptation
+ * to dynamically call FindClass rather than add a small cache to each file that needs one. Another
+ * cost is that each class cached here requires a global reference, though in practice we save
+ * enough by not having a global reference for each file that uses a class such as java.lang.String
+ * which is used in several files.
+ *
+ * FindClass is still called in a couple of situations: when throwing exceptions, and in some of
+ * the serialization code. The former is clearly not a performance case, and we're currently
+ * assuming that neither is the latter.
+ *
+ * TODO: similar arguments hold for field and method IDs; we should cache them centrally too.
+ */
+struct JniConstants {
+    static void init(JNIEnv* env);
+
+    static jclass booleanClass;
+    static jclass byteArrayClass;
+    static jclass calendarClass;
+    static jclass charsetICUClass;
+    static jclass doubleClass;
+    static jclass errnoExceptionClass;
+    static jclass fileDescriptorClass;
+    static jclass gaiExceptionClass;
+    static jclass inet6AddressClass;
+    static jclass inet6AddressHolderClass;
+    static jclass inetAddressClass;
+    static jclass inetAddressHolderClass;
+    static jclass inetSocketAddressClass;
+    static jclass inetSocketAddressHolderClass;
+    static jclass integerClass;
+    static jclass localeDataClass;
+    static jclass longClass;
+    static jclass netlinkSocketAddressClass;
+    static jclass packetSocketAddressClass;
+    static jclass patternSyntaxExceptionClass;
+    static jclass referenceClass;
+    static jclass socketTaggerClass;
+    static jclass stringClass;
+    static jclass structAddrinfoClass;
+    static jclass structFlockClass;
+    static jclass structGroupReqClass;
+    static jclass structIfaddrs;
+    static jclass structLingerClass;
+    static jclass structPasswdClass;
+    static jclass structPollfdClass;
+    static jclass structStatClass;
+    static jclass structStatVfsClass;
+    static jclass structTimevalClass;
+    static jclass structTimespecClass;
+    static jclass structUcredClass;
+    static jclass structUtsnameClass;
+    static jclass unixSocketAddressClass;
+    static jclass zipEntryClass;
+};
+
+#define NATIVE_METHOD(className, functionName, signature) \
+    { #functionName, signature, reinterpret_cast<void*>(className ## _ ## functionName) }
+
+#endif  // JNI_CONSTANTS_H_included
diff --git a/core/jni/include/nativehelper/JniInvocation.h b/core/jni/include/nativehelper/JniInvocation.h
new file mode 100644
index 000000000000..58beec5c14d5
--- /dev/null
+++ b/core/jni/include/nativehelper/JniInvocation.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JNI_INVOCATION_H_included
+#define JNI_INVOCATION_H_included
+
+#include <jni.h>
+
+// JniInvocation adds a layer of indirection for applications using
+// the JNI invocation API to allow the JNI implementation to be
+// selected dynamically. Apps can specify a specific implementation to
+// be used by calling InitJniInvocation. If this is not done, the
+// library will chosen based on the value of Android system property
+// persist.sys.dalvik.vm.lib on the device, and otherwise fall back to
+// a hard-coded default implementation.
+class JniInvocation {
+ public:
+  JniInvocation();
+
+  ~JniInvocation();
+
+  // Initialize JNI invocation API. library should specifiy a valid
+  // shared library for opening via dlopen providing a JNI invocation
+  // implementation, or null to allow defaulting via
+  // persist.sys.dalvik.vm.lib.
+  bool Init(const char* library);
+
+  // Exposes which library is actually loaded from the given name. The
+  // buffer of size PROPERTY_VALUE_MAX will be used to load the system
+  // property for the default library, if necessary. If no buffer is
+  // provided, the fallback value will be used.
+  static const char* GetLibrary(const char* library, char* buffer);
+
+ private:
+  static const char* GetLibrary(const char* library, char* buffer, bool (*is_debuggable)(),
+                                int (*get_library_system_property)(char* buffer));
+
+  bool FindSymbol(void** pointer, const char* symbol);
+
+  static JniInvocation& GetJniInvocation();
+
+  jint JNI_GetDefaultJavaVMInitArgs(void* vmargs);
+  jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args);
+  jint JNI_GetCreatedJavaVMs(JavaVM** vms, jsize size, jsize* vm_count);
+
+  static JniInvocation* jni_invocation_;
+
+  void* handle_;
+  jint (*JNI_GetDefaultJavaVMInitArgs_)(void*);
+  jint (*JNI_CreateJavaVM_)(JavaVM**, JNIEnv**, void*);
+  jint (*JNI_GetCreatedJavaVMs_)(JavaVM**, jsize, jsize*);
+
+  friend jint JNI_GetDefaultJavaVMInitArgs(void* vm_args);
+  friend jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args);
+  friend jint JNI_GetCreatedJavaVMs(JavaVM** vms, jsize size, jsize* vm_count);
+  friend class JNIInvocation_Debuggable_Test;
+  friend class JNIInvocation_NonDebuggable_Test;
+};
+
+#endif  // JNI_INVOCATION_H_included
diff --git a/core/jni/include/nativehelper/ScopedBytes.h b/core/jni/include/nativehelper/ScopedBytes.h
new file mode 100644
index 000000000000..7cb2ad09c67b
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedBytes.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_BYTES_H_included
+#define SCOPED_BYTES_H_included
+
+#include "JNIHelp.h"
+#include <nativehelper/scoped_bytes.h>
+
+#endif  // SCOPED_BYTES_H_included
diff --git a/core/jni/include/nativehelper/ScopedLocalFrame.h b/core/jni/include/nativehelper/ScopedLocalFrame.h
new file mode 100644
index 000000000000..57873f271e6a
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedLocalFrame.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_LOCAL_FRAME_H_included
+#define SCOPED_LOCAL_FRAME_H_included
+
+#include <nativehelper/scoped_local_frame.h>
+
+#endif  // SCOPED_LOCAL_FRAME_H_included
diff --git a/core/jni/include/nativehelper/ScopedLocalRef.h b/core/jni/include/nativehelper/ScopedLocalRef.h
new file mode 100644
index 000000000000..0fb03d75ac7c
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedLocalRef.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_LOCAL_REF_H_included
+#define SCOPED_LOCAL_REF_H_included
+
+#include "JNIHelp.h"
+#include <nativehelper/scoped_local_ref.h>
+
+#endif  // SCOPED_LOCAL_REF_H_included
diff --git a/core/jni/include/nativehelper/ScopedPrimitiveArray.h b/core/jni/include/nativehelper/ScopedPrimitiveArray.h
new file mode 100644
index 000000000000..626b64f18f13
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedPrimitiveArray.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_PRIMITIVE_ARRAY_H_included
+#define SCOPED_PRIMITIVE_ARRAY_H_included
+
+#include "JNIHelp.h"
+#include <nativehelper/scoped_primitive_array.h>
+
+#endif  // SCOPED_PRIMITIVE_ARRAY_H_included
diff --git a/core/jni/include/nativehelper/ScopedStringChars.h b/core/jni/include/nativehelper/ScopedStringChars.h
new file mode 100644
index 000000000000..59c405c09f16
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedStringChars.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_STRING_CHARS_H_included
+#define SCOPED_STRING_CHARS_H_included
+
+#include "JNIHelp.h"
+#include <nativehelper/scoped_string_chars.h>
+
+#endif  // SCOPED_STRING_CHARS_H_included
diff --git a/core/jni/include/nativehelper/ScopedUtfChars.h b/core/jni/include/nativehelper/ScopedUtfChars.h
new file mode 100644
index 000000000000..f123115feb28
--- /dev/null
+++ b/core/jni/include/nativehelper/ScopedUtfChars.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef SCOPED_UTF_CHARS_H_included
+#define SCOPED_UTF_CHARS_H_included
+
+#include "JNIHelp.h"
+#include <nativehelper/scoped_utf_chars.h>
+
+#endif  // SCOPED_UTF_CHARS_H_included
diff --git a/core/jni/include/nativehelper/UniquePtr.h b/core/jni/include/nativehelper/UniquePtr.h
new file mode 100644
index 000000000000..ac88be1d902d
--- /dev/null
+++ b/core/jni/include/nativehelper/UniquePtr.h
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef UNIQUE_PTR_H_included
+#define UNIQUE_PTR_H_included
+
+#include <cstdlib> // For NULL.
+#include "JNIHelp.h"  // For DISALLOW_COPY_AND_ASSIGN.
+
+// Default deleter for pointer types.
+template <typename T>
+struct DefaultDelete {
+    enum { type_must_be_complete = sizeof(T) };
+    DefaultDelete() {}
+    void operator()(T* p) const {
+        delete p;
+    }
+};
+
+// Default deleter for array types.
+template <typename T>
+struct DefaultDelete<T[]> {
+    enum { type_must_be_complete = sizeof(T) };
+    void operator()(T* p) const {
+        delete[] p;
+    }
+};
+
+// A smart pointer that deletes the given pointer on destruction.
+// Equivalent to C++0x's std::unique_ptr (a combination of boost::scoped_ptr
+// and boost::scoped_array).
+// Named to be in keeping with Android style but also to avoid
+// collision with any other implementation, until we can switch over
+// to unique_ptr.
+// Use thus:
+//   UniquePtr<C> c(new C);
+template <typename T, typename D = DefaultDelete<T> >
+class UniquePtr {
+public:
+    // Construct a new UniquePtr, taking ownership of the given raw pointer.
+    explicit UniquePtr(T* ptr = NULL) : mPtr(ptr) {
+    }
+
+    ~UniquePtr() {
+        reset();
+    }
+
+    // Accessors.
+    T& operator*() const { return *mPtr; }
+    T* operator->() const { return mPtr; }
+    T* get() const { return mPtr; }
+
+    // Returns the raw pointer and hands over ownership to the caller.
+    // The pointer will not be deleted by UniquePtr.
+    T* release() __attribute__((warn_unused_result)) {
+        T* result = mPtr;
+        mPtr = NULL;
+        return result;
+    }
+
+    // Takes ownership of the given raw pointer.
+    // If this smart pointer previously owned a different raw pointer, that
+    // raw pointer will be freed.
+    void reset(T* ptr = NULL) {
+        if (ptr != mPtr) {
+            D()(mPtr);
+            mPtr = ptr;
+        }
+    }
+
+private:
+    // The raw pointer.
+    T* mPtr;
+
+    // Comparing unique pointers is probably a mistake, since they're unique.
+    template <typename T2> bool operator==(const UniquePtr<T2>& p) const;
+    template <typename T2> bool operator!=(const UniquePtr<T2>& p) const;
+
+    DISALLOW_COPY_AND_ASSIGN(UniquePtr);
+};
+
+// Partial specialization for array types. Like std::unique_ptr, this removes
+// operator* and operator-> but adds operator[].
+template <typename T, typename D>
+class UniquePtr<T[], D> {
+public:
+    explicit UniquePtr(T* ptr = NULL) : mPtr(ptr) {
+    }
+
+    ~UniquePtr() {
+        reset();
+    }
+
+    T& operator[](size_t i) const {
+        return mPtr[i];
+    }
+    T* get() const { return mPtr; }
+
+    T* release() __attribute__((warn_unused_result)) {
+        T* result = mPtr;
+        mPtr = NULL;
+        return result;
+    }
+
+    void reset(T* ptr = NULL) {
+        if (ptr != mPtr) {
+            D()(mPtr);
+            mPtr = ptr;
+        }
+    }
+
+private:
+    T* mPtr;
+
+    DISALLOW_COPY_AND_ASSIGN(UniquePtr);
+};
+
+#if UNIQUE_PTR_TESTS
+
+// Run these tests with:
+// g++ -g -DUNIQUE_PTR_TESTS -x c++ UniquePtr.h && ./a.out
+
+#include <stdio.h>
+
+static void assert(bool b) {
+    if (!b) {
+        fprintf(stderr, "FAIL\n");
+        abort();
+    }
+    fprintf(stderr, "OK\n");
+}
+static int cCount = 0;
+struct C {
+    C() { ++cCount; }
+    ~C() { --cCount; }
+};
+static bool freed = false;
+struct Freer {
+    void operator()(int* p) {
+        assert(*p == 123);
+        free(p);
+        freed = true;
+    }
+};
+
+int main(int argc, char* argv[]) {
+    //
+    // UniquePtr<T> tests...
+    //
+
+    // Can we free a single object?
+    {
+        UniquePtr<C> c(new C);
+        assert(cCount == 1);
+    }
+    assert(cCount == 0);
+    // Does release work?
+    C* rawC;
+    {
+        UniquePtr<C> c(new C);
+        assert(cCount == 1);
+        rawC = c.release();
+    }
+    assert(cCount == 1);
+    delete rawC;
+    // Does reset work?
+    {
+        UniquePtr<C> c(new C);
+        assert(cCount == 1);
+        c.reset(new C);
+        assert(cCount == 1);
+    }
+    assert(cCount == 0);
+
+    //
+    // UniquePtr<T[]> tests...
+    //
+
+    // Can we free an array?
+    {
+        UniquePtr<C[]> cs(new C[4]);
+        assert(cCount == 4);
+    }
+    assert(cCount == 0);
+    // Does release work?
+    {
+        UniquePtr<C[]> c(new C[4]);
+        assert(cCount == 4);
+        rawC = c.release();
+    }
+    assert(cCount == 4);
+    delete[] rawC;
+    // Does reset work?
+    {
+        UniquePtr<C[]> c(new C[4]);
+        assert(cCount == 4);
+        c.reset(new C[2]);
+        assert(cCount == 2);
+    }
+    assert(cCount == 0);
+
+    //
+    // Custom deleter tests...
+    //
+    assert(!freed);
+    {
+        UniquePtr<int, Freer> i(reinterpret_cast<int*>(malloc(sizeof(int))));
+        *i = 123;
+    }
+    assert(freed);
+    return 0;
+}
+#endif
+
+#endif  // UNIQUE_PTR_H_included
diff --git a/core/jni/include/nativehelper/toStringArray.h b/core/jni/include/nativehelper/toStringArray.h
new file mode 100644
index 000000000000..cb46024fef8c
--- /dev/null
+++ b/core/jni/include/nativehelper/toStringArray.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TO_STRING_ARRAY_H_included
+#define TO_STRING_ARRAY_H_included
+
+#include "jni.h"
+#include "ScopedLocalRef.h"
+
+#include <string>
+#include <vector>
+
+jobjectArray newStringArray(JNIEnv* env, size_t count);
+
+template <typename Counter, typename Getter>
+jobjectArray toStringArray(JNIEnv* env, Counter* counter, Getter* getter) {
+    size_t count = (*counter)();
+    jobjectArray result = newStringArray(env, count);
+    if (result == NULL) {
+        return NULL;
+    }
+    for (size_t i = 0; i < count; ++i) {
+        ScopedLocalRef<jstring> s(env, env->NewStringUTF((*getter)(i)));
+        if (env->ExceptionCheck()) {
+            return NULL;
+        }
+        env->SetObjectArrayElement(result, i, s.get());
+        if (env->ExceptionCheck()) {
+            return NULL;
+        }
+    }
+    return result;
+}
+
+struct VectorCounter {
+    const std::vector<std::string>& strings;
+    explicit VectorCounter(const std::vector<std::string>& strings) : strings(strings) {}
+    size_t operator()() {
+        return strings.size();
+    }
+};
+struct VectorGetter {
+    const std::vector<std::string>& strings;
+    explicit VectorGetter(const std::vector<std::string>& strings) : strings(strings) {}
+    const char* operator()(size_t i) {
+        return strings[i].c_str();
+    }
+};
+
+inline jobjectArray toStringArray(JNIEnv* env, const std::vector<std::string>& strings) {
+    VectorCounter counter(strings);
+    VectorGetter getter(strings);
+    return toStringArray<VectorCounter, VectorGetter>(env, &counter, &getter);
+}
+
+JNIEXPORT jobjectArray toStringArray(JNIEnv* env, const char* const* strings);
+
+#endif  // TO_STRING_ARRAY_H_included
-- 
2.17.1

