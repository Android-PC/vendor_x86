From b25809777e43e0f43216e0970d7bb36cce941eca Mon Sep 17 00:00:00 2001
From: Dileep Marchya <dmarchya@codeaurora.org>
Date: Thu, 24 May 2018 23:47:55 +0530
Subject: [PATCH] display: Add support for multiple displays.

- Add support for multiple builtin and external displays.
- Add mapping for physical to logical displays.
- External and virtual displays will continue to use
  present way of logical display ids assignment.
- Additional builtin displays will be assigned logical
  ids from 4096 onwards.

CRs-Fixed: 2274419
Change-Id: I0a86af9fdd07202efc1f99b14687f27af921c503
---
 core/java/android/view/SurfaceControl.java    |  9 +++++++
 .../android/server/display/DisplayDevice.java | 17 ++++++++++++
 .../server/display/DisplayManagerService.java | 12 ++++++++-
 .../server/display/LocalDisplayAdapter.java   | 26 +++++++++++++++++--
 4 files changed, 61 insertions(+), 3 deletions(-)

diff --git a/core/java/android/view/SurfaceControl.java b/core/java/android/view/SurfaceControl.java
index ed8b0053e5bf..e887056de23a 100644
--- a/core/java/android/view/SurfaceControl.java
+++ b/core/java/android/view/SurfaceControl.java
@@ -302,6 +302,15 @@ public class SurfaceControl implements Parcelable {
      */
     public static final int BUILT_IN_DISPLAY_ID_HDMI = 1;
 
+    /**
+     * Built-in physical display id: Additional Built-in display id range.
+     * HDMI display ID range will be HDMI ID to EXT_MIN ID.
+     * Built-in display ID range will bee EXT_MIN ID to EXT_MAX ID.
+     * Use only with {@link SurfaceControl#getBuiltInDisplay(int)}.
+     */
+    public static final int BUILT_IN_DISPLAY_ID_EXT_MIN = 5;
+    public static final int BUILT_IN_DISPLAY_ID_EXT_MAX = 7;
+
     /* Display power modes * /
 
     /**
diff --git a/services/core/java/com/android/server/display/DisplayDevice.java b/services/core/java/com/android/server/display/DisplayDevice.java
index 240592528565..7bb144da9633 100644
--- a/services/core/java/com/android/server/display/DisplayDevice.java
+++ b/services/core/java/com/android/server/display/DisplayDevice.java
@@ -36,6 +36,7 @@ abstract class DisplayDevice {
     private final DisplayAdapter mDisplayAdapter;
     private final IBinder mDisplayToken;
     private final String mUniqueId;
+    private int mPhysicalId = -1;
 
     // The display device does not manage these properties itself, they are set by
     // the display manager service.  The display device shouldn't really be looking at these.
@@ -52,6 +53,12 @@ abstract class DisplayDevice {
     // Do not use for any other purpose.
     DisplayDeviceInfo mDebugLastLoggedDeviceInfo;
 
+    public DisplayDevice(DisplayAdapter displayAdapter, IBinder displayToken, String uniqueId,
+                         int physicalId) {
+      this(displayAdapter, displayToken, uniqueId);
+      mPhysicalId = physicalId;
+    }
+
     public DisplayDevice(DisplayAdapter displayAdapter, IBinder displayToken, String uniqueId) {
         mDisplayAdapter = displayAdapter;
         mDisplayToken = displayToken;
@@ -86,6 +93,15 @@ abstract class DisplayDevice {
         return getDisplayDeviceInfoLocked().name;
     }
 
+    /**
+     * Gets the physical id (vendor specified) of the display device.
+     *
+     * @return The display device id.
+     */
+    public final int getPhysicalId() {
+        return mPhysicalId;
+    }
+
     /**
      * Returns the unique id of the display device.
      */
@@ -233,6 +249,7 @@ abstract class DisplayDevice {
     public void dumpLocked(PrintWriter pw) {
         pw.println("mAdapter=" + mDisplayAdapter.getName());
         pw.println("mUniqueId=" + mUniqueId);
+        pw.println("mPhysicalId=" + mPhysicalId);
         pw.println("mDisplayToken=" + mDisplayToken);
         pw.println("mCurrentLayerStack=" + mCurrentLayerStack);
         pw.println("mCurrentOrientation=" + mCurrentOrientation);
diff --git a/services/core/java/com/android/server/display/DisplayManagerService.java b/services/core/java/com/android/server/display/DisplayManagerService.java
index cc5a8271eb5f..eea22cfdd966 100644
--- a/services/core/java/com/android/server/display/DisplayManagerService.java
+++ b/services/core/java/com/android/server/display/DisplayManagerService.java
@@ -207,6 +207,7 @@ public final class DisplayManagerService extends SystemService {
     private final SparseArray<LogicalDisplay> mLogicalDisplays =
             new SparseArray<LogicalDisplay>();
     private int mNextNonDefaultDisplayId = Display.DEFAULT_DISPLAY + 1;
+    private int mNextBuiltInDisplayId = 4096;
 
     // List of all display transaction listeners.
     private final CopyOnWriteArrayList<DisplayTransactionListener> mDisplayTransactionListeners =
@@ -1001,7 +1002,7 @@ public final class DisplayManagerService extends SystemService {
             return null;
         }
 
-        final int displayId = assignDisplayIdLocked(isDefault);
+        final int displayId = assignDisplayIdLocked(isDefault, device.getPhysicalId());
         final int layerStack = assignLayerStackLocked(displayId);
 
         LogicalDisplay display = new LogicalDisplay(displayId, layerStack, device);
@@ -1034,6 +1035,15 @@ public final class DisplayManagerService extends SystemService {
         return isDefault ? Display.DEFAULT_DISPLAY : mNextNonDefaultDisplayId++;
     }
 
+    private int assignDisplayIdLocked(boolean isDefault, int physicalId) {
+        if (physicalId >= SurfaceControl.BUILT_IN_DISPLAY_ID_EXT_MIN &&
+            physicalId <= SurfaceControl.BUILT_IN_DISPLAY_ID_EXT_MAX) {
+            return mNextBuiltInDisplayId++;
+        }
+
+        return assignDisplayIdLocked(isDefault);
+    }
+
     private int assignLayerStackLocked(int displayId) {
         // Currently layer stacks and display ids are the same.
         // This need not be the case.
diff --git a/services/core/java/com/android/server/display/LocalDisplayAdapter.java b/services/core/java/com/android/server/display/LocalDisplayAdapter.java
index b0813fb1a4e3..811d659e73f3 100644
--- a/services/core/java/com/android/server/display/LocalDisplayAdapter.java
+++ b/services/core/java/com/android/server/display/LocalDisplayAdapter.java
@@ -183,7 +183,8 @@ final class LocalDisplayAdapter extends DisplayAdapter {
         public LocalDisplayDevice(IBinder displayToken, int builtInDisplayId,
                 SurfaceControl.PhysicalDisplayInfo[] physicalDisplayInfos, int activeDisplayInfo,
                 int[] colorModes, int activeColorMode) {
-            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId);
+            super(LocalDisplayAdapter.this, displayToken, UNIQUE_ID_PREFIX + builtInDisplayId,
+                  builtInDisplayId);
             mBuiltInDisplayId = builtInDisplayId;
             updatePhysicalDisplayInfoLocked(physicalDisplayInfos, activeDisplayInfo,
                     colorModes, activeColorMode);
@@ -414,7 +415,8 @@ final class LocalDisplayAdapter extends DisplayAdapter {
                     mInfo.xDpi = phys.xDpi;
                     mInfo.yDpi = phys.yDpi;
                     mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
-                } else {
+                } else if (mBuiltInDisplayId >= SurfaceControl.BUILT_IN_DISPLAY_ID_HDMI &&
+                           mBuiltInDisplayId < SurfaceControl.BUILT_IN_DISPLAY_ID_EXT_MIN) {
                     mInfo.displayCutout = null;
                     mInfo.type = Display.TYPE_HDMI;
                     mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
@@ -443,6 +445,26 @@ final class LocalDisplayAdapter extends DisplayAdapter {
                     if (res.getBoolean(com.android.internal.R.bool.config_localDisplaysPrivate)) {
                         mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
                     }
+                } else {
+                    mInfo.type = Display.TYPE_BUILT_IN;
+                    mInfo.touch = DisplayDeviceInfo.TOUCH_INTERNAL;
+                    mInfo.name = getContext().getResources().getString(
+                            com.android.internal.R.string.display_manager_built_in_display_name);
+                    mInfo.flags |= DisplayDeviceInfo.FLAG_ROTATES_WITH_CONTENT;
+
+                    if (SystemProperties.getBoolean(
+                                    "vendor.display.builtin_presentation", false)) {
+                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRESENTATION;
+                    } else {
+                        mInfo.flags |= DisplayDeviceInfo.FLAG_PRIVATE;
+                    }
+
+                    if (!SystemProperties.getBoolean(
+                                    "vendor.display.builtin_mirroring", false)) {
+                        mInfo.flags |= DisplayDeviceInfo.FLAG_OWN_CONTENT_ONLY;
+                    }
+
+                    mInfo.setAssumedDensityForExternalDisplay(phys.width, phys.height);
                 }
             }
             return mInfo;
-- 
2.17.1

