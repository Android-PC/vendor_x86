From f909acbc873419c636ea0317e8929e3679a4e18c Mon Sep 17 00:00:00 2001
From: Tim Joines <tjoines@google.com>
Date: Wed, 18 Mar 2020 18:00:41 +0000
Subject: [PATCH 2/2] Revert "Share vdex files in the ART apex between
 architectures (..."

Revert submission 1254009-vdex-symlinks

Reason for revert: This causing some devices to fail to boot. See b/151836042 for details.
Reverted Changes:
Iced89071b:Expect vdex files in a target-independent director...
Ifbceb8457:Share vdex files in the ART apex between architect...

Change-Id: I5bd88f8e61d442eed921d840c90777a2750ddb16
---
 apex/apex.go               | 17 +----------------
 apex/builder.go            | 10 +---------
 java/dexpreopt_bootjars.go | 28 ++++++++--------------------
 3 files changed, 10 insertions(+), 45 deletions(-)

diff --git a/apex/apex.go b/apex/apex.go
index c31ed765..46aaa8b5 100644
--- a/apex/apex.go
+++ b/apex/apex.go
@@ -2311,10 +2311,7 @@ func (a *apexBundle) GenerateAndroidBuildActions(ctx android.ModuleContext) {
 	// Build rules are generated by the dexpreopt singleton, and here we access build artifacts
 	// via the global boot image config.
 	if a.artApex {
-		artAndOatFiles, vdexFiles := java.DexpreoptedArtApexJars(ctx)
-
-		// Copy *.art and *.oat files to arch-specific subdirectories.
-		for arch, files := range artAndOatFiles {
+		for arch, files := range java.DexpreoptedArtApexJars(ctx) {
 			dirInApex := filepath.Join("javalib", arch.String())
 			for _, f := range files {
 				localModule := "javalib_" + arch.String() + "_" + filepath.Base(f.String())
@@ -2322,18 +2319,6 @@ func (a *apexBundle) GenerateAndroidBuildActions(ctx android.ModuleContext) {
 				filesInfo = append(filesInfo, af)
 			}
 		}
-
-		// Copy *.vdex files to a common subdirectory.
-		for _, file := range vdexFiles {
-			dirInApex := "javalib"
-			localModule := "javalib_" + filepath.Base(file.String())
-			af := newApexFile(ctx, file, localModule, dirInApex, etc, nil)
-			// Add a symlink to the *.vdex file for each arch-specific subdirectory.
-			for arch := range artAndOatFiles {
-				af.symlinks = append(af.symlinks, filepath.Join(arch.String(), filepath.Base(file.String())))
-			}
-			filesInfo = append(filesInfo, af)
-		}
 	}
 
 	if a.private_key_file == nil {
diff --git a/apex/builder.go b/apex/builder.go
index ea1215e1..67bc2060 100644
--- a/apex/builder.go
+++ b/apex/builder.go
@@ -333,7 +333,6 @@ func (a *apexBundle) buildUnflattenedApex(ctx android.ModuleContext) {
 	for _, fi := range a.filesInfo {
 		destPath := android.PathForModuleOut(ctx, "image"+suffix, fi.Path()).String()
 		copyCommands = append(copyCommands, "mkdir -p "+filepath.Dir(destPath))
-
 		if a.linkToSystemLib && fi.transitiveDep && fi.AvailableToPlatform() {
 			// TODO(jiyong): pathOnDevice should come from fi.module, not being calculated here
 			pathOnDevice := filepath.Join("/system", fi.Path())
@@ -342,16 +341,10 @@ func (a *apexBundle) buildUnflattenedApex(ctx android.ModuleContext) {
 			copyCommands = append(copyCommands, "cp -f "+fi.builtFile.String()+" "+destPath)
 			implicitInputs = append(implicitInputs, fi.builtFile)
 		}
-
 		// create additional symlinks pointing the file inside the APEX
 		for _, symlinkPath := range fi.SymlinkPaths() {
 			symlinkDest := android.PathForModuleOut(ctx, "image"+suffix, symlinkPath).String()
-			symlinkTarget, err := filepath.Rel(filepath.Dir(symlinkDest), destPath)
-			if err != nil {
-				panic("Cannot compute relative path from " + destPath + " to " + filepath.Dir(symlinkDest))
-			}
-			copyCommands = append(copyCommands, "mkdir -p "+filepath.Dir(symlinkDest))
-			copyCommands = append(copyCommands, "ln -sfn "+symlinkTarget+" "+symlinkDest)
+			copyCommands = append(copyCommands, "ln -sfn "+filepath.Base(destPath)+" "+symlinkDest)
 		}
 	}
 
@@ -414,7 +407,6 @@ func (a *apexBundle) buildUnflattenedApex(ctx android.ModuleContext) {
 				}
 			} else {
 				readOnlyPaths = append(readOnlyPaths, pathInApex)
-				readOnlyPaths = append(readOnlyPaths, f.SymlinkPaths()...)
 			}
 			dir := f.installDir
 			for !android.InList(dir, executablePaths) && dir != "" {
diff --git a/java/dexpreopt_bootjars.go b/java/dexpreopt_bootjars.go
index 0751c086..a3b264ed 100644
--- a/java/dexpreopt_bootjars.go
+++ b/java/dexpreopt_bootjars.go
@@ -186,31 +186,19 @@ type dexpreoptBootJars struct {
 }
 
 // Accessor function for the apex package. Returns nil if dexpreopt is disabled.
-func DexpreoptedArtApexJars(ctx android.BuilderContext) (map[android.ArchType]android.OutputPaths, android.OutputPaths) {
+func DexpreoptedArtApexJars(ctx android.BuilderContext) map[android.ArchType]android.OutputPaths {
 	if skipDexpreoptBootJars(ctx) {
-		return nil, nil
+		return nil
 	}
-
-	image := artBootImageConfig(ctx)
-
-	// Target-independent boot image files (*.vdex).
-	anyTarget := image.variants[0].target
-	vdexDir := image.dir.Join(ctx, anyTarget.Os.String(), image.installSubdir, anyTarget.Arch.ArchType.String())
-	vdexFiles := image.moduleFiles(ctx, vdexDir, ".vdex")
-
-	// Target-specific boot image files (*.oat, *.art).
-	artAndOatFiles := map[android.ArchType]android.OutputPaths{}
-	for _, variant := range image.variants {
+	// Include dexpreopt files for the primary boot image.
+	files := map[android.ArchType]android.OutputPaths{}
+	for _, variant := range artBootImageConfig(ctx).variants {
 		// We also generate boot images for host (for testing), but we don't need those in the apex.
-		os := variant.target.Os
-		if os == android.Android {
-			arch := variant.target.Arch.ArchType
-			archDir := image.dir.Join(ctx, os.String(), image.installSubdir, arch.String())
-			artAndOatFiles[arch] = image.moduleFiles(ctx, archDir, ".art", ".oat")
+		if variant.target.Os == android.Android {
+			files[variant.target.Arch.ArchType] = variant.imagesDeps
 		}
 	}
-
-	return artAndOatFiles, vdexFiles
+	return files
 }
 
 // dexpreoptBoot singleton rules
-- 
2.25.1

